<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>torgo Web UI - Basic</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { color: #2c3e50; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
        .container { max-width: 1000px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .status-section, .instances-section { margin-bottom: 20px; }
        .instance-card { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .instance-card h3 { margin-top: 0; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: middle; }
        .status-healthy { background-color: green; }
        .status-unhealthy { background-color: red; }
        .status-unknown { background-color: orange; }
        button { padding: 8px 12px; margin-top: 10px; margin-right: 5px; border: none; border-radius: 4px; cursor: pointer; background-color: #3498db; color: white; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .loading-spinner {
            border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%;
            width: 14px; height: 14px; animation: spin 1s linear infinite;
            display: inline-block; margin-left: 5px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        #statsModal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.4); padding-top: 60px;
        }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 5px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>torgo Web UI (Basic)</h1>
            <p>Manage and Monitor Your Tor Instances</p>
        </header>

        <section class="status-section">
            <h2>Common Proxy Status</h2>
            <p>SOCKS5 Proxy (<span id="commonSocksPortDisplay">N/A</span>): <span id="commonSocksStatus">Loading...</span></p>
            <p>DNS Proxy (<span id="commonDnsPortDisplay">N/A</span>): <span id="commonDnsStatus">Loading...</span></p>
            <p>Last updated: <span id="lastUpdatedTimestamp">Never</span> <button id="refreshAllButton">Refresh All</button></p>
        </section>

        <section class="instances-section">
            <h2>Tor Instances (<span id="instanceCount">0</span>)</h2>
            <button id="rotateAllStaggeredButton">Rotate All Healthy Staggered</button>
            <div id="instancesContainer">
                </div>
        </section>

        <div id="statsModal">
            <div class="modal-content">
                <span class="close-button" id="closeModalButton">&times;</span>
                <h3 id="modalTitle">Instance Stats</h3>
                <pre id="modalStatsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = `${window.location.origin}/api/v1`;
        let appDetails = null;
        let instancesData = {};
        let refreshIntervalId = null;
        const REFRESH_INTERVAL_MS = 20000; // Refresh every 20 seconds

        // DOM Elements
        const commonSocksPortDisplay = document.getElementById('commonSocksPortDisplay');
        const commonSocksStatus = document.getElementById('commonSocksStatus');
        const commonDnsPortDisplay = document.getElementById('commonDnsPortDisplay');
        const commonDnsStatus = document.getElementById('commonDnsStatus');
        const instancesContainer = document.getElementById('instancesContainer');
        const instanceCountDisplay = document.getElementById('instanceCount');
        const lastUpdatedTimestamp = document.getElementById('lastUpdatedTimestamp');
        const refreshAllButton = document.getElementById('refreshAllButton');
        const rotateAllStaggeredButton = document.getElementById('rotateAllStaggeredButton');

        const statsModal = document.getElementById('statsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalStatsContent = document.getElementById('modalStatsContent');
        const closeModalButton = document.getElementById('closeModalButton');

        async function fetchData(urlPath) {
            try {
                const response = await fetch(`${API_BASE_URL}${urlPath}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.warn(`Fetch error for ${urlPath}: ${response.status} - ${errorText}`);
                    return { error: `HTTP ${response.status}: ${errorText}` };
                }
                return await response.json();
            } catch (error) {
                console.warn(`Network error fetching ${urlPath}:`, error);
                return { error: error.message };
            }
        }
        
        async function postData(urlPath) {
             try {
                const response = await fetch(`${API_BASE_URL}${urlPath}`, { method: 'POST' });
                const responseText = await response.text(); // Get text first for potential non-JSON errors
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}: ${responseText}`);
                }
                try { // Try to parse as JSON if successful
                    return JSON.parse(responseText);
                } catch (e) { // If not JSON, return the text
                    return responseText;
                }
            } catch (error) {
                console.error(`POST error for ${urlPath}:`, error);
                return { error: error.message, rawError: error };
            }
        }


        function createInstanceCard(instanceId) {
            const card = document.createElement('div');
            card.id = `instance-${instanceId}-card`;
            card.className = 'instance-card';
            card.innerHTML = `
                <h3>Instance ${instanceId}</h3>
                <p>Status: <span id="instance-${instanceId}-status-dot" class="status-dot status-unknown"></span><span id="instance-${instanceId}-status-text">Loading...</span></p>
                <p><small>Control: <span id="instance-${instanceId}-control">N/A</span></small></p>
                <p><small>SOCKS: <span id="instance-${instanceId}-socks">N/A</span></small></p>
                <p><small>Bootstrap: <span id="instance-${instanceId}-bootstrap">N/A</span></small></p>
                <button id="rotate-btn-${instanceId}">New Circuit <span id="rotate-spinner-${instanceId}" class="loading-spinner" style="display:none;"></span></button>
                <button id="stats-btn-${instanceId}">View Stats</button>
            `;
            instancesContainer.appendChild(card);

            document.getElementById(`rotate-btn-${instanceId}`).addEventListener('click', () => handleNewCircuitClick(instanceId));
            document.getElementById(`stats-btn-${instanceId}`).addEventListener('click', () => showFullStats(instanceId));
        }

        function updateInstanceCard(instanceId, data) {
            const statusDot = document.getElementById(`instance-${instanceId}-status-dot`);
            const statusText = document.getElementById(`instance-${instanceId}-status-text`);
            const bootstrapText = document.getElementById(`instance-${instanceId}-bootstrap`);
            const controlText = document.getElementById(`instance-${instanceId}-control`);
            const socksText = document.getElementById(`instance-${instanceId}-socks`);

            if (data.health && !data.health.error) {
                statusDot.className = data.health.cached_is_healthy ? 'status-dot status-healthy' : 'status-dot status-unhealthy';
                statusText.textContent = data.health.cached_is_healthy ? 'Healthy' : 'Unhealthy';
            } else {
                statusDot.className = 'status-dot status-unknown';
                statusText.textContent = (data.health && data.health.error) ? `Error: ${data.health.error}` : 'No health data';
            }

            if (data.stats && !data.stats.error) {
                const bootstrapSummary = data.stats.bootstrap_status ? data.stats.bootstrap_status.match(/SUMMARY="([^"]+)"/) : null;
                bootstrapText.textContent = bootstrapSummary ? bootstrapSummary[1] : (data.stats.bootstrap_status || 'N/A');
            } else {
                 bootstrapText.textContent = (data.stats && data.stats.error) ? `Error: ${data.stats.error}` : 'No stats data';
            }
            
            if (data.config && !data.config.error) {
                controlText.textContent = data.config.control_host || 'N/A';
                socksText.textContent = data.config.backend_socks_host || 'N/A';
            } else {
                controlText.textContent = 'N/A';
                socksText.textContent = 'N/A';
            }
        }
        
        async function showFullStats(instanceId) {
            modalTitle.textContent = `Full Stats for Instance ${instanceId}`;
            modalStatsContent.textContent = 'Loading stats...';
            statsModal.style.display = "block";

            const stats = await fetchData(`/tor${instanceId}/stats`);
            if (stats.error) {
                modalStatsContent.textContent = `Error fetching stats: ${stats.error}`;
            } else {
                modalStatsContent.textContent = JSON.stringify(stats, null, 2);
            }
        }

        closeModalButton.onclick = function() {
            statsModal.style.display = "none";
        }
        window.onclick = function(event) {
            if (event.target == statsModal) {
                statsModal.style.display = "none";
            }
        }

        async function handleNewCircuitClick(instanceId) {
            const button = document.getElementById(`rotate-btn-${instanceId}`);
            const spinner = document.getElementById(`rotate-spinner-${instanceId}`);
            button.disabled = true;
            spinner.style.display = 'inline-block';

            const result = await postData(`/tor${instanceId}/rotate`);
            if (result.error) {
                alert(`Error requesting new circuit for instance ${instanceId}: ${result.error.message || result.error}`);
            } else {
                // alert(`Instance ${instanceId}: New circuit requested.\nResponse: ${typeof result === 'string' ? result : JSON.stringify(result)}`);
                document.getElementById(`instance-${instanceId}-status-text`).textContent = 'Rotation requested...';
            }
            button.disabled = false;
            spinner.style.display = 'none';
            setTimeout(() => fetchAndRenderAllInstances(), 2000); // Refresh sooner after action
        }
        
        rotateAllStaggeredButton.onclick = async function() {
            rotateAllStaggeredButton.disabled = true;
            rotateAllStaggeredButton.textContent = "Rotating All...";
            
            // For streaming, we'd need a different approach (e.g., EventSource or long polling)
            // For a simple POST and wait:
            const result = await postData(`/rotate-all-staggered`);
             if (result.error) {
                alert(`Error rotating all instances: ${result.error.message || result.error}`);
            } else {
                alert(`Staggered rotation initiated for all healthy instances. Check individual statuses or logs for progress.\nResponse snippet: ${typeof result === 'string' ? result.substring(0,100) : JSON.stringify(result).substring(0,100)}...`);
            }

            rotateAllStaggeredButton.disabled = false;
            rotateAllStaggeredButton.textContent = "Rotate All Healthy Staggered";
            setTimeout(() => fetchAndRenderAllInstances(), 5000); // Refresh after a bit
        }


        function updateCommonProxyStatusDisplay() {
            let healthyCount = 0;
            let totalConfiguredInstances = (appDetails && appDetails.num_instances) ? appDetails.num_instances : 0;
            
            Object.values(instancesData).forEach(data => {
                if (data && data.health && !data.health.error && data.health.cached_is_healthy) {
                    healthyCount++;
                }
            });

            if (totalConfiguredInstances === 0) {
                 commonSocksStatus.innerHTML = 'No instances configured.';
                 commonDnsStatus.innerHTML = 'No instances configured.';
            } else if (Object.keys(instancesData).length < totalConfiguredInstances && Object.keys(instancesData).length === 0) {
                 commonSocksStatus.innerHTML = `Awaiting first health check for ${totalConfiguredInstances} instances...`;
                 commonDnsStatus.innerHTML = `Awaiting first health check for ${totalConfiguredInstances} instances...`;
            } else if (healthyCount > 0) {
                commonSocksStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyCount}/${totalConfiguredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyCount}/${totalConfiguredInstances} healthy)`;
            } else {
                commonSocksStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${totalConfiguredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${totalConfiguredInstances} healthy)`;
            }
        }

        async function fetchAndRenderAllInstances() {
            if (!appDetails) {
                const num = await fetchAppDetails();
                if (num === 0 && !appDetails) { // Still no appDetails after fetch (e.g. API error)
                    instancesContainer.innerHTML = '<p>Error fetching application details. Cannot load instances.</p>';
                    updateCommonProxyStatusDisplay();
                    return;
                }
            }
            if (!appDetails || appDetails.num_instances === 0) {
                 instancesContainer.innerHTML = '<p>No Tor instances configured.</p>';
                 updateCommonProxyStatusDisplay();
                 return;
            }

            const numInstances = appDetails.num_instances;
            const instancePromises = [];
            instancesContainer.innerHTML = ''; // Clear old cards before creating new ones

            for (let i = 1; i <= numInstances; i++) {
                createInstanceCard(i); // Create card structure first
                instancePromises.push(
                    Promise.all([
                        fetchData(`/tor${i}/health`), 
                        fetchData(`/tor${i}/stats`),
                        fetchData(`/tor${i}/config`)
                    ]).then(([health, stats, config]) => {
                        instancesData[i] = { health, stats, config };
                        updateInstanceCard(i, instancesData[i]);
                    }).catch(error => {
                        console.error(`Error fetching data bundle for instance ${i}:`, error);
                        updateInstanceCard(i, { health: {error: 'Fetch failed'}, stats: {error: 'Fetch failed'}, config: {error: 'Fetch failed'} });
                    })
                );
            }
            
            try {
                await Promise.all(instancePromises);
            } catch (e) {
                console.error("Error during Promise.all for instance data fetching:", e);
            }
            updateCommonProxyStatusDisplay();
            lastUpdatedTimestamp.textContent = new Date().toLocaleTimeString();
        }
        
        refreshAllButton.addEventListener('click', () => {
            lastUpdatedTimestamp.textContent = 'Refreshing...';
            fetchAndRenderAllInstances();
        });

        async function initializeUI() {
            await fetchAndRenderAllInstances(); 
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(fetchAndRenderAllInstances, REFRESH_INTERVAL_MS);
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
