<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>torgo Web UI - Basic</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { color: #2c3e50; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
        .container { max-width: 1000px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .status-section, .instances-section { margin-bottom: 20px; }
        .instance-card { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .instance-card h3 { margin-top: 0; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: middle; }
        .status-healthy { background-color: green; }
        .status-unhealthy { background-color: red; }
        .status-unknown { background-color: orange; }
        button { padding: 8px 12px; margin-top: 10px; margin-right: 5px; border: none; border-radius: 4px; cursor: pointer; background-color: #3498db; color: white; font-size: 0.9em; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .btn-small { padding: 5px 8px; font-size: 0.8em; margin-top: 5px;}
        .loading-spinner {
            border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%;
            width: 14px; height: 14px; animation: spin 1s linear infinite;
            display: inline-block; margin-left: 5px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; font-size: 0.85em; }
        #statsModal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.4); padding-top: 60px;
        }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 5px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .info-label { font-weight: 500; color: #555;}
        .info-value { font-family: monospace; color: #2c3e50; font-size: 0.9em; }
        .card-actions { display: flex; flex-wrap: wrap; gap: 5px; margin-top:10px; border-top: 1px solid #eee; padding-top: 10px;}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>torgo Web UI (Basic)</h1>
            <p>Manage and Monitor Your Tor Instances</p>
        </header>

        <section class="status-section">
            <h2>Common Proxy Status</h2>
            <p>SOCKS5 Proxy (<span id="commonSocksPortDisplay">N/A</span>): <span id="commonSocksStatus">Loading...</span></p>
            <p>DNS Proxy (<span id="commonDnsPortDisplay">N/A</span>): <span id="commonDnsStatus">Loading...</span></p>
            <p>Last updated: <span id="lastUpdatedTimestamp">Never</span> <button id="refreshAllButton">Refresh All Data</button></p>
        </section>

        <section class="instances-section">
            <h2>Tor Instances (<span id="instanceCount">0</span>)</h2>
            <button id="rotateAllStaggeredButton">Rotate All Healthy Staggered</button>
            <div id="instancesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                </div>
        </section>

        <div id="statsModal">
            <div class="modal-content">
                <span class="close-button" id="closeModalButton">&times;</span>
                <h3 id="modalTitle">Instance Stats</h3>
                <pre id="modalStatsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = `${window.location.origin}/api/v1`;
        let appDetails = null;
        let instancesData = {}; 
        let refreshIntervalId = null;
        const REFRESH_INTERVAL_MS = 20000; 

        const commonSocksPortDisplay = document.getElementById('commonSocksPortDisplay');
        const commonSocksStatus = document.getElementById('commonSocksStatus');
        const commonDnsPortDisplay = document.getElementById('commonDnsPortDisplay');
        const commonDnsStatus = document.getElementById('commonDnsStatus');
        const instancesContainer = document.getElementById('instancesContainer');
        const instanceCountDisplay = document.getElementById('instanceCount');
        const lastUpdatedTimestamp = document.getElementById('lastUpdatedTimestamp');
        const refreshAllButton = document.getElementById('refreshAllButton');
        const rotateAllStaggeredButton = document.getElementById('rotateAllStaggeredButton');
        const statsModal = document.getElementById('statsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalStatsContent = document.getElementById('modalStatsContent');
        const closeModalButton = document.getElementById('closeModalButton');

        async function fetchData(urlPath, options = {}) {
            try {
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.warn(`Fetch error for ${urlPath}: ${response.status} - ${errorText}`);
                    return { error: `HTTP ${response.status}: ${errorText.substring(0, 100)}` };
                }
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return await response.json();
                } else {
                    return { plain_text_response: await response.text() }; 
                }
            } catch (error) {
                console.warn(`Network error fetching ${urlPath}:`, error);
                return { error: error.message };
            }
        }
        
        async function postData(urlPath, body = null) {
             try {
                const options = { method: 'POST' };
                if (body) {
                    options.headers = { 'Content-Type': 'application/json' };
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                const responseText = await response.text(); 
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}: ${responseText}`);
                }
                try { 
                    return JSON.parse(responseText);
                } catch (e) { 
                    return responseText; 
                }
            } catch (error) {
                console.error(`POST error for ${urlPath}:`, error);
                return { error: error.message, rawError: error };
            }
        }

        function createInstanceCard(instanceId) {
            let card = document.getElementById(`instance-${instanceId}-card`);
            if (card) return; 

            card = document.createElement('div');
            card.id = `instance-${instanceId}-card`;
            card.className = 'instance-card';
            card.innerHTML = `
                <h3>Instance ${instanceId}</h3>
                <p><span class="info-label">Status:</span> <span id="instance-${instanceId}-status-dot" class="status-dot status-unknown"></span><span id="instance-${instanceId}-status-text">Loading...</span></p>
                <p><small><span class="info-label">Control Port:</span> <span id="instance-${instanceId}-control" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Backend SOCKS:</span> <span id="instance-${instanceId}-socks" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Backend DNS:</span> <span id="instance-${instanceId}-dns" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">External IP:</span> <span id="instance-${instanceId}-ip" class="info-value">Loading...</span> <button id="refresh-ip-btn-${instanceId}" class="btn-small" title="Refresh IP for this instance">ðŸ”„ IP</button></small></p>
                <p><small><span class="info-label">Bootstrap:</span> <span id="instance-${instanceId}-bootstrap" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Version:</span> <span id="instance-${instanceId}-version" class="info-value">N/A</span></small></p>
                <div class="card-actions">
                    <button id="rotate-btn-${instanceId}">New Circuit <span id="rotate-spinner-${instanceId}" class="loading-spinner" style="display:none;"></span></button>
                    <button id="stats-btn-${instanceId}">View Stats</button>
                    <button id="refresh-instance-btn-${instanceId}" class="btn-small">Refresh Data</button>
                </div>
            `;
            instancesContainer.appendChild(card);

            document.getElementById(`rotate-btn-${instanceId}`).addEventListener('click', () => handleNewCircuitClick(instanceId));
            document.getElementById(`stats-btn-${instanceId}`).addEventListener('click', () => showFullStats(instanceId));
            document.getElementById(`refresh-instance-btn-${instanceId}`).addEventListener('click', () => {
                document.getElementById(`instance-${instanceId}-status-text`).textContent = 'Refreshing...';
                fetchAndRenderInstanceData(instanceId);
            });
            document.getElementById(`refresh-ip-btn-${instanceId}`).addEventListener('click', async () => {
                const ipElem = document.getElementById(`instance-${instanceId}-ip`);
                ipElem.textContent = 'Fetching IP...';
                const ipData = await fetchData(`/tor${instanceId}/ip`);
                instancesData[instanceId] = { ...instancesData[instanceId], ip: ipData };
                updateInstanceCardUI(instanceId, instancesData[instanceId]);
            });
        }

        function updateInstanceCardUI(instanceId, data) {
            const getElem = (suffix) => document.getElementById(`instance-${instanceId}-${suffix}`);
            const statusDot = getElem('status-dot');
            const statusText = getElem('status-text');
            const bootstrapText = getElem('bootstrap');
            const versionText = getElem('version');
            const controlText = getElem('control');
            const socksText = getElem('socks');
            const dnsText = getElem('dns');
            const ipText = getElem('ip');

            if (!statusDot) return; 

            if (data && data.health && !data.health.error) {
                statusDot.className = data.health.cached_is_healthy ? 'status-dot status-healthy' : 'status-dot status-unhealthy';
                statusText.textContent = data.health.cached_is_healthy ? 'Healthy' : 'Unhealthy';
                 if (data.health.last_health_check_at) {
                    statusText.textContent += ` (as of ${new Date(data.health.last_health_check_at).toLocaleTimeString()})`;
                }
            } else {
                statusDot.className = 'status-dot status-unknown';
                statusText.textContent = (data && data.health && data.health.error) ? `Error: ${data.health.error}` : 'Health N/A';
            }

            if (data && data.stats && !data.stats.error) {
                const bootstrapSummary = data.stats.bootstrap_status ? data.stats.bootstrap_status.match(/SUMMARY="([^"]+)"/) : null;
                bootstrapText.textContent = bootstrapSummary ? bootstrapSummary[1] : (data.stats.bootstrap_status || 'N/A');
                versionText.textContent = data.stats.version || "N/A";
            } else {
                 bootstrapText.textContent = (data && data.stats && data.stats.error) ? `Error: ${data.stats.error}` : 'Stats N/A';
                 versionText.textContent = "N/A";
            }
            
            if (data && data.config && !data.config.error) {
                controlText.textContent = data.config.control_host || 'N/A';
                socksText.textContent = data.config.backend_socks_host || 'N/A';
                dnsText.textContent = data.config.backend_dns_host || 'N/A';
            } else {
                controlText.textContent = 'N/A';
                socksText.textContent = 'N/A';
                dnsText.textContent = 'N/A';
            }

            if (data && data.ip && !data.ip.error) {
                ipText.textContent = data.ip.IP || (data.ip.plain_text_response ? 'Non-JSON IP ('+ data.ip.plain_text_response.substring(0,30) +'...)' : 'N/A');
            } else {
                ipText.textContent = (data && data.ip && data.ip.error) ? `Error: ${data.ip.error}` : 'IP N/A';
            }
        }
        
        async function showFullStats(instanceId) {
            modalTitle.textContent = `Full Stats for Instance ${instanceId}`;
            modalStatsContent.textContent = 'Loading stats...';
            statsModal.style.display = "block";

            const stats = await fetchData(`/tor${instanceId}/stats`);
            if (stats.error) {
                modalStatsContent.textContent = `Error fetching stats: ${stats.error}`;
            } else {
                modalStatsContent.textContent = JSON.stringify(stats, null, 2);
            }
        }

        closeModalButton.onclick = function() { statsModal.style.display = "none"; }
        window.onclick = function(event) { if (event.target == statsModal) { statsModal.style.display = "none"; } }

        async function handleNewCircuitClick(instanceId) {
            const button = document.getElementById(`rotate-btn-${instanceId}`);
            const spinner = document.getElementById(`rotate-spinner-${instanceId}`);
            button.disabled = true;
            spinner.style.display = 'inline-block';

            const result = await postData(`/tor${instanceId}/rotate`);
            if (result.error) {
                alert(`Error requesting new circuit for instance ${instanceId}: ${result.error.message || result.error}`);
            } else {
                document.getElementById(`instance-${instanceId}-status-text`).textContent = 'Rotation requested...';
            }
            button.disabled = false;
            spinner.style.display = 'none';
            // Fetch data for this specific instance again soon after rotation
            setTimeout(() => fetchAndRenderInstanceData(instanceId), 3000); 
        }
        
        rotateAllStaggeredButton.onclick = async function() {
            rotateAllStaggeredButton.disabled = true;
            rotateAllStaggeredButton.textContent = "Rotating All (Streaming)...";
            
            try {
                const response = await fetch(`${API_BASE_URL}/rotate-all-staggered`, { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                // For a truly streaming response, you'd process response.body.getReader()
                // For this basic UI, we'll just acknowledge and let user check logs/status later via refresh
                alert(`Staggered rotation initiated. Monitor Web UI or server logs for progress. UI will refresh periodically.`);

            } catch (error) {
                alert(`Error initiating staggered rotation: ${error.message}`);
                 console.error("Staggered rotation error:", error);
            }

            rotateAllStaggeredButton.disabled = false;
            rotateAllStaggeredButton.textContent = "Rotate All Healthy Staggered";
            setTimeout(() => fetchAndRenderAllInstances(), 5000); 
        }

        function updateCommonProxyStatusDisplay() {
            let healthyBackendCount = 0;
            const configuredInstances = (appDetails && appDetails.num_instances) ? parseInt(appDetails.num_instances, 10) : 0;

            if (configuredInstances > 0) {
                for (let i = 1; i <= configuredInstances; i++) {
                    if (instancesData[i] && instancesData[i].health && !instancesData[i].health.error && instancesData[i].health.cached_is_healthy === true) {
                        healthyBackendCount++;
                    }
                }
            }
            
            commonSocksPortDisplay.textContent = (appDetails && appDetails.common_socks_port) ? appDetails.common_socks_port : 'N/A';
            commonDnsPortDisplay.textContent = (appDetails && appDetails.common_dns_port) ? appDetails.common_dns_port : 'N/A';

            if (!appDetails) { 
                commonSocksStatus.textContent = 'Loading app details...';
                commonDnsStatus.textContent = 'Loading app details...';
            } else if (configuredInstances === 0) {
                commonSocksStatus.innerHTML = 'No instances configured.';
                commonDnsStatus.innerHTML = 'No instances configured.';
            } else if (healthyBackendCount > 0) {
                commonSocksStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyBackendCount}/${configuredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyBackendCount}/${configuredInstances} healthy)`;
            } else { 
                commonSocksStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${configuredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${configuredInstances} healthy)`;
            }
        }
        
        async function fetchAndRenderInstanceData(instanceId) {
            if (!document.getElementById(`instance-${instanceId}-card`)) {
                createInstanceCard(instanceId);
            }
            try {
                const [health, stats, config, ip] = await Promise.all([
                    fetchData(`/tor${instanceId}/health`), 
                    fetchData(`/tor${instanceId}/stats`),
                    fetchData(`/tor${instanceId}/config`),
                    fetchData(`/tor${instanceId}/ip`)
                ]);
                instancesData[instanceId] = { health, stats, config, ip }; 
                updateInstanceCardUI(instanceId, instancesData[instanceId]);
            } catch (error) {
                 console.error(`Error fetching data bundle for instance ${instanceId}:`, error);
                 updateInstanceCardUI(instanceId, { 
                     health: {error: 'Fetch bundle failed'}, 
                     stats: {error: 'Fetch bundle failed'}, 
                     config: {error: 'Fetch bundle failed'},
                     ip: {error: 'Fetch bundle failed'} 
                 });
            }
        }

        async function fetchAndRenderAllInstances() {
            if (!appDetails) { // Ensure appDetails is fetched if not already
                const details = await fetchData("/app-details");
                if (details.error || typeof details.num_instances === 'undefined') { 
                     appDetails = { num_instances: 0, common_socks_port: 'N/A', common_dns_port: 'N/A' }; 
                     console.error("Error fetching application details or num_instances missing:", details.error);
                } else {
                    appDetails = details;
                }
            }
            
            instanceCountDisplay.textContent = appDetails.num_instances || 0;
            commonSocksPortDisplay.textContent = appDetails.common_socks_port || 'N/A';
            commonDnsPortDisplay.textContent = appDetails.common_dns_port || 'N/A';

            const numInstances = appDetails.num_instances || 0; // Use 0 if undefined
            if (numInstances === 0) {
                 instancesContainer.innerHTML = '<p>No Tor instances configured.</p>';
                 updateCommonProxyStatusDisplay(); // Still update common status
                 return;
            }
            
            const instancePromises = [];
            for (let i = 1; i <= numInstances; i++) {
                // Ensure card exists before pushing promise to fetch data for it
                if (!document.getElementById(`instance-${i}-card`)) {
                    createInstanceCard(i);
                }
                instancePromises.push(fetchAndRenderInstanceData(i));
            }
            
            try {
                await Promise.all(instancePromises);
            } catch (e) {
                console.error("Error during Promise.all for instance data fetching:", e);
            }
            updateCommonProxyStatusDisplay();
            lastUpdatedTimestamp.textContent = new Date().toLocaleTimeString();
        }
        
        refreshAllButton.addEventListener('click', () => {
            lastUpdatedTimestamp.textContent = 'Refreshing...';
            fetchAndRenderAllInstances();
        });

        async function initializeUI() {
            await fetchAndRenderAllInstances(); 
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(fetchAndRenderAllInstances, REFRESH_INTERVAL_MS);
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
