<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>torgo Web UI - Basic</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        header { text-align: center; margin-bottom: 20px; }
        h1 { color: #2c3e50; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
        .container { max-width: 1000px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .status-section, .instances-section { margin-bottom: 20px; }
        .instance-card { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #f9f9f9; }
        .instance-card h3 { margin-top: 0; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: middle; }
        .status-healthy { background-color: green; }
        .status-unhealthy { background-color: red; }
        .status-unknown { background-color: orange; }
        button { padding: 8px 12px; margin-top: 10px; margin-right: 5px; border: none; border-radius: 4px; cursor: pointer; background-color: #3498db; color: white; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .loading-spinner {
            border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%;
            width: 14px; height: 14px; animation: spin 1s linear infinite;
            display: inline-block; margin-left: 5px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        #statsModal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.4); padding-top: 60px;
        }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 5px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>torgo Web UI (Basic)</h1>
            <p>Manage and Monitor Your Tor Instances</p>
        </header>

        <section class="status-section">
            <h2>Common Proxy Status</h2>
            <p>SOCKS5 Proxy (<span id="commonSocksPortDisplay">N/A</span>): <span id="commonSocksStatus">Loading...</span></p>
            <p>DNS Proxy (<span id="commonDnsPortDisplay">N/A</span>): <span id="commonDnsStatus">Loading...</span></p>
            <p>Last updated: <span id="lastUpdatedTimestamp">Never</span> <button id="refreshAllButton">Refresh All</button></p>
        </section>

        <section class="instances-section">
            <h2>Tor Instances (<span id="instanceCount">0</span>)</h2>
            <button id="rotateAllStaggeredButton">Rotate All Healthy Staggered</button>
            <div id="instancesContainer">
                </div>
        </section>

        <div id="statsModal">
            <div class="modal-content">
                <span class="close-button" id="closeModalButton">&times;</span>
                <h3 id="modalTitle">Instance Stats</h3>
                <pre id="modalStatsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = `${window.location.origin}/api/v1`;
        let appDetails = null;
        let instancesData = {}; // { 1: {health: {}, stats: {}, config: {}}, ... }
        let refreshIntervalId = null;
        const REFRESH_INTERVAL_MS = 20000;

        const commonSocksPortDisplay = document.getElementById('commonSocksPortDisplay');
        const commonSocksStatus = document.getElementById('commonSocksStatus');
        const commonDnsPortDisplay = document.getElementById('commonDnsPortDisplay');
        const commonDnsStatus = document.getElementById('commonDnsStatus');
        const instancesContainer = document.getElementById('instancesContainer');
        const instanceCountDisplay = document.getElementById('instanceCount');
        const lastUpdatedTimestamp = document.getElementById('lastUpdatedTimestamp');
        const refreshAllButton = document.getElementById('refreshAllButton');
        const rotateAllStaggeredButton = document.getElementById('rotateAllStaggeredButton');
        const statsModal = document.getElementById('statsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalStatsContent = document.getElementById('modalStatsContent');
        const closeModalButton = document.getElementById('closeModalButton');

        async function fetchData(urlPath, options = {}) {
            try {
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.warn(`Fetch error for ${urlPath}: ${response.status} - ${errorText}`);
                    return { error: `HTTP ${response.status}: ${errorText.substring(0, 100)}` }; // Limit error length
                }
                return await response.json();
            } catch (error) {
                console.warn(`Network error fetching ${urlPath}:`, error);
                return { error: error.message };
            }
        }
        
        async function postData(urlPath, body = null) {
             try {
                const options = { method: 'POST' };
                if (body) {
                    options.headers = { 'Content-Type': 'application/json' };
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                const responseText = await response.text(); 
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}: ${responseText}`);
                }
                try { 
                    return JSON.parse(responseText);
                } catch (e) { 
                    return responseText; // Return as text if not JSON (e.g. simple "OK" string)
                }
            } catch (error) {
                console.error(`POST error for ${urlPath}:`, error);
                return { error: error.message, rawError: error };
            }
        }

        function createInstanceCard(instanceId) {
            let card = document.getElementById(`instance-${instanceId}-card`);
            if (card) return; // Already exists

            card = document.createElement('div');
            card.id = `instance-${instanceId}-card`;
            card.className = 'instance-card';
            card.innerHTML = `
                <h3>Instance ${instanceId}</h3>
                <p>Status: <span id="instance-${instanceId}-status-dot" class="status-dot status-unknown"></span><span id="instance-${instanceId}-status-text">Loading...</span></p>
                <p><small>Control: <span id="instance-${instanceId}-control">N/A</span></small></p>
                <p><small>SOCKS: <span id="instance-${instanceId}-socks">N/A</span></small></p>
                <p><small>Bootstrap: <span id="instance-${instanceId}-bootstrap">N/A</span></small></p>
                <p><small>Version: <span id="instance-${instanceId}-version">N/A</span></small></p>
                <button id="rotate-btn-${instanceId}">New Circuit <span id="rotate-spinner-${instanceId}" class="loading-spinner" style="display:none;"></span></button>
                <button id="stats-btn-${instanceId}">View Stats</button>
            `;
            instancesContainer.appendChild(card);

            document.getElementById(`rotate-btn-${instanceId}`).addEventListener('click', () => handleNewCircuitClick(instanceId));
            document.getElementById(`stats-btn-${instanceId}`).addEventListener('click', () => showFullStats(instanceId));
        }

        function updateInstanceCardUI(instanceId, data) {
            const getElem = (suffix) => document.getElementById(`instance-${instanceId}-${suffix}`);
            const statusDot = getElem('status-dot');
            const statusText = getElem('status-text');
            const bootstrapText = getElem('bootstrap');
            const versionText = getElem('version');
            const controlText = getElem('control');
            const socksText = getElem('socks');

            if (!statusDot) return; // Card might not be fully ready if called too early

            if (data.health && !data.health.error) {
                statusDot.className = data.health.cached_is_healthy ? 'status-dot status-healthy' : 'status-dot status-unhealthy';
                statusText.textContent = data.health.cached_is_healthy ? 'Healthy' : 'Unhealthy';
                 if (data.health.last_health_check_at) {
                    statusText.textContent += ` (as of ${new Date(data.health.last_health_check_at).toLocaleTimeString()})`;
                }
            } else {
                statusDot.className = 'status-dot status-unknown';
                statusText.textContent = (data.health && data.health.error) ? `Error: ${data.health.error}` : 'Health N/A';
            }

            if (data.stats && !data.stats.error) {
                const bootstrapSummary = data.stats.bootstrap_status ? data.stats.bootstrap_status.match(/SUMMARY="([^"]+)"/) : null;
                bootstrapText.textContent = bootstrapSummary ? bootstrapSummary[1] : (data.stats.bootstrap_status || 'N/A');
                versionText.textContent = data.stats.version || "N/A";
            } else {
                 bootstrapText.textContent = (data.stats && data.stats.error) ? `Error: ${data.stats.error}` : 'Stats N/A';
                 versionText.textContent = "N/A";
            }
            
            if (data.config && !data.config.error) {
                controlText.textContent = data.config.control_host || 'N/A';
                socksText.textContent = data.config.backend_socks_host || 'N/A';
            } else {
                controlText.textContent = 'N/A';
                socksText.textContent = 'N/A';
            }
        }
        
        async function showFullStats(instanceId) {
            modalTitle.textContent = `Full Stats for Instance ${instanceId}`;
            modalStatsContent.textContent = 'Loading stats...';
            statsModal.style.display = "block";

            const stats = await fetchData(`/tor${instanceId}/stats`);
            if (stats.error) {
                modalStatsContent.textContent = `Error fetching stats: ${stats.error}`;
            } else {
                modalStatsContent.textContent = JSON.stringify(stats, null, 2);
            }
        }

        closeModalButton.onclick = function() { statsModal.style.display = "none"; }
        window.onclick = function(event) { if (event.target == statsModal) { statsModal.style.display = "none"; } }

        async function handleNewCircuitClick(instanceId) {
            const button = document.getElementById(`rotate-btn-${instanceId}`);
            const spinner = document.getElementById(`rotate-spinner-${instanceId}`);
            button.disabled = true;
            spinner.style.display = 'inline-block';

            const result = await postData(`/tor${instanceId}/rotate`);
            if (result.error) {
                alert(`Error requesting new circuit for instance ${instanceId}: ${result.error.message || result.error}`);
            } else {
                document.getElementById(`instance-${instanceId}-status-text`).textContent = 'Rotation requested...';
            }
            button.disabled = false;
            spinner.style.display = 'none';
            setTimeout(() => fetchAndRenderInstanceData(instanceId), 2000); 
        }
        
        rotateAllStaggeredButton.onclick = async function() {
            rotateAllStaggeredButton.disabled = true;
            rotateAllStaggeredButton.textContent = "Rotating All (Streaming)...";
            
            try {
                const response = await fetch(`${API_BASE_URL}/rotate-all-staggered`, { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                // For streaming, you'd typically read response.body with a ReadableStream
                // For this basic UI, we'll just acknowledge and let user check logs/status later
                alert(`Staggered rotation initiated. Monitor Web UI or server logs for progress.`);

            } catch (error) {
                alert(`Error initiating staggered rotation: ${error.message}`);
                 console.error("Staggered rotation error:", error);
            }

            rotateAllStaggeredButton.disabled = false;
            rotateAllStaggeredButton.textContent = "Rotate All Healthy Staggered";
            setTimeout(() => fetchAndRenderAllInstances(), 5000); 
        }

        function updateCommonProxyStatusDisplay() {
            let healthyBackendCount = 0;
            const configuredInstances = (appDetails && appDetails.num_instances) ? parseInt(appDetails.num_instances, 10) : 0;

            if (configuredInstances > 0) {
                for (let i = 1; i <= configuredInstances; i++) {
                    if (instancesData[i] && instancesData[i].health && !instancesData[i].health.error && instancesData[i].health.cached_is_healthy === true) {
                        healthyBackendCount++;
                    }
                }
            }
            
            commonSocksPortDisplay.textContent = (appDetails && appDetails.common_socks_port) ? appDetails.common_socks_port : 'N/A';
            commonDnsPortDisplay.textContent = (appDetails && appDetails.common_dns_port) ? appDetails.common_dns_port : 'N/A';

            if (!appDetails) { // appDetails not yet fetched
                commonSocksStatus.textContent = 'Loading app details...';
                commonDnsStatus.textContent = 'Loading app details...';
            } else if (configuredInstances === 0) {
                commonSocksStatus.innerHTML = 'No instances configured.';
                commonDnsStatus.innerHTML = 'No instances configured.';
            } else if (healthyBackendCount > 0) {
                commonSocksStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyBackendCount}/${configuredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-healthy"></span>Operational (${healthyBackendCount}/${configuredInstances} healthy)`;
            } else { 
                commonSocksStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${configuredInstances} healthy)`;
                commonDnsStatus.innerHTML = `<span class="status-dot status-unhealthy"></span>Offline (0/${configuredInstances} healthy)`;
            }
        }
        
        async function fetchAndRenderInstanceData(instanceId) {
            if (!document.getElementById(`instance-${instanceId}-card`)) {
                createInstanceCard(instanceId);
            }
            try {
                const [health, stats, config] = await Promise.all([
                    fetchData(`/tor${instanceId}/health`),
                    fetchData(`/tor${instanceId}/stats`),
                    fetchData(`/tor${instanceId}/config`)
                ]);
                instancesData[instanceId] = { health, stats, config };
                updateInstanceCardUI(instanceId, instancesData[instanceId]);
            } catch (error) {
                 console.error(`Error fetching data bundle for instance ${instanceId}:`, error);
                 updateInstanceCardUI(instanceId, { 
                     health: {error: 'Fetch bundle failed'}, 
                     stats: {error: 'Fetch bundle failed'}, 
                     config: {error: 'Fetch bundle failed'} 
                 });
            }
        }


        async function fetchAndRenderAllInstances() {
            if (!appDetails) {
                const num = await fetchData("/app-details").then(d => d.num_instances || 0);
                if (num === 0 && !appDetails) { 
                    if (!appDetails) appDetails = { num_instances: 0 }; // Ensure appDetails is not null
                    instancesContainer.innerHTML = '<p>Error fetching application details or no instances configured.</p>';
                    updateCommonProxyStatusDisplay(); // Update with current appDetails
                    return;
                }
                // If fetchAppDetails was successful, appDetails global var is set
            }
             if (!appDetails) { // Still no appDetails, something went wrong
                console.error("App details could not be fetched for rendering instances.");
                instancesContainer.innerHTML = '<p>Critical error: Could not fetch application details.</p>';
                updateCommonProxyStatusDisplay();
                return;
            }


            const numInstances = appDetails.num_instances;
            instanceCountDisplay.textContent = numInstances; // Update count here
            if (numInstances === 0) {
                 instancesContainer.innerHTML = '<p>No Tor instances configured.</p>';
                 updateCommonProxyStatusDisplay();
                 return;
            }
            
            const instancePromises = [];
            // instancesContainer.innerHTML = ''; // Clear only if we are sure we are re-rendering all

            for (let i = 1; i <= numInstances; i++) {
                instancePromises.push(fetchAndRenderInstanceData(i));
            }
            
            try {
                await Promise.all(instancePromises);
            } catch (e) {
                console.error("Error during Promise.all for instance data fetching:", e);
            }
            updateCommonProxyStatusDisplay();
            lastUpdatedTimestamp.textContent = new Date().toLocaleTimeString();
        }
        
        refreshAllButton.addEventListener('click', () => {
            lastUpdatedTimestamp.textContent = 'Refreshing...';
            // Clear existing instance data to force full re-fetch and re-render
            // instancesData = {}; 
            // instancesContainer.innerHTML = ''; // Optionally clear cards for visual refresh
            fetchAndRenderAllInstances();
        });

        async function initializeUI() {
            appDetails = await fetchData("/app-details"); // Fetch app details first
            if (appDetails.error) {
                console.error("Initialization failed: could not fetch app details.", appDetails.error);
                commonSocksStatus.textContent = `Error: ${appDetails.error}`;
                commonDnsStatus.textContent = `Error: ${appDetails.error}`;
                instanceCountDisplay.textContent = 'Error';
                return;
            }
            commonSocksPortDisplay.textContent = appDetails.common_socks_port || 'N/A';
            commonDnsPortDisplay.textContent = appDetails.common_dns_port || 'N/A';
            instanceCountDisplay.textContent = appDetails.num_instances || 0;


            await fetchAndRenderAllInstances(); 
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(fetchAndRenderAllInstances, REFRESH_INTERVAL_MS);
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
