<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>torgo Web UI - Advanced</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; line-height: 1.6; }
        header { text-align: center; margin-bottom: 30px; padding-bottom:20px; border-bottom: 1px solid #dddfe2;}
        h1 { color: #1877f2; font-size: 2.2em; margin-bottom: 8px;}
        h2 { border-bottom: 1px solid #dddfe2; padding-bottom: 10px; margin-top: 35px; font-size: 1.6em; color: #333; }
        h3 { margin-top: 0; color: #1877f2; font-size: 1.3em; }
        h4 { font-size: 1.1em; color: #4b5563; margin-top: 15px; margin-bottom: 8px; }
        .container { max-width: 1200px; margin: auto; background-color: #fff; padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .instance-card { border: 1px solid #dddfe2; border-radius: 8px; padding: 20px; margin-bottom: 20px; background-color: #f9fafb; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: middle; }
        .status-healthy { background-color: #10b981; } /* Emerald 500 */
        .status-unhealthy { background-color: #ef4444; } /* Red 500 */
        .status-unknown { background-color: #f59e0b; } /* Amber 500 */
        button, input[type="submit"] { padding: 9px 18px; margin-top: 12px; margin-right: 10px; border: none; border-radius: 6px; cursor: pointer; background-color: #1877f2; color: white; font-size: 0.95em; font-weight: 500; transition: background-color 0.2s; }
        button:hover, input[type="submit"]:hover { background-color: #166fe5; }
        button:disabled, input[type="submit"]:disabled { background-color: #ccd0d5; color: #8a8d91; cursor: not-allowed; }
        .btn-small { padding: 6px 12px; font-size: 0.85em; margin-top: 5px;}
        .loading-spinner { border: 2px solid #f3f3f3; border-top: 2px solid #1877f2; border-radius: 50%; width: 14px; height: 14px; animation: spin 1s linear infinite; display: inline-block; margin-left: 5px; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        pre { background-color: #f3f4f6; padding: 15px; border-radius: 6px; overflow-x: auto; white-space: pre-wrap; font-size: 0.9em; border: 1px solid #e5e7eb; }
        #statsModal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); padding-top: 60px; }
        .modal-content { background-color: #fff; margin: 5% auto; padding: 30px; border: 1px solid #dddfe2; width: 90%; max-width: 800px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .close-button { color: #aaa; float: right; font-size: 32px; font-weight: bold; line-height: 0.7; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .info-label { font-weight: 600; color: #4b5563; min-width:160px; display:inline-block; }
        .info-value { font-family: Menlo, Monaco, Consolas, "Courier New", monospace; color: #1f2937; font-size: 0.9em; }
        .card-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top:15px; border-top: 1px solid #e5e7eb; padding-top: 15px;}
        .grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 25px; }
        .app-config-details p, .perf-metrics-list li, .node-policy-section p { margin: 8px 0; font-size: 0.95em; }
        .perf-metrics-list { list-style-type: none; padding-left: 0; }
        .perf-metrics-list li { background-color: #f9fafb; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 4px; margin-bottom: 6px; }
        .perf-metrics-list .metric-value { font-weight: bold; }
        .perf-metrics-list .metric-target { color: #1877f2; }
        .perf-metrics-list .metric-stale { color: #ef4444; font-style: italic; }
        .node-policy-section input[type="text"] { width: calc(100% - 110px); padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }
        .node-policy-section button { margin-top: 0; vertical-align: middle; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>torgo Control Panel</h1>
            <p>Manage, Monitor, and Optimize Your Tor Instances</p>
        </header>

        <section class="app-config-section">
            <h2>Application Configuration</h2>
            <div id="appConfigDetailsContainer" class="app-config-details">Loading app configuration...</div>
        </section>

        <section class="status-section">
            <h2>Common Proxy Status</h2>
            <p><span class="info-label">SOCKS5 Proxy:</span> <span id="commonSocksPortDisplay" class="info-value">N/A</span> - Status: <span id="commonSocksStatus">Loading...</span></p>
            <p><span class="info-label">DNS Proxy:</span> <span id="commonDnsPortDisplay" class="info-value">N/A</span> - Status: <span id="commonDnsStatus">Loading...</span></p>
            <p>Last updated: <span id="lastUpdatedTimestamp" class="info-value">Never</span> <button id="refreshAllButton">Refresh All Data</button></p>
        </section>

        <section class="instances-section">
            <h2>Tor Instances (<span id="instanceCount">0</span>)</h2>
            <button id="rotateAllStaggeredButton">Rotate All Healthy Staggered</button>
            <div id="instancesContainer" class="grid-container"></div>
        </section>

        <div id="statsModal">
            <div class="modal-content">
                <span class="close-button" id="closeModalButton">&times;</span>
                <h3 id="modalTitle">Instance Stats</h3>
                <pre id="modalStatsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = `${window.location.origin}/api/v1`;
        let appDetails = null;
        let instancesData = {}; // Store { health, stats, config, perfMetrics }
        let refreshIntervalId = null;
        const REFRESH_INTERVAL_MS = 25000; // Refresh interval

        // DOM Elements
        const appConfigDetailsContainer = document.getElementById('appConfigDetailsContainer');
        const commonSocksPortDisplay = document.getElementById('commonSocksPortDisplay');
        const commonSocksStatus = document.getElementById('commonSocksStatus');
        const commonDnsPortDisplay = document.getElementById('commonDnsPortDisplay');
        const commonDnsStatus = document.getElementById('commonDnsStatus');
        const instancesContainer = document.getElementById('instancesContainer');
        const instanceCountDisplay = document.getElementById('instanceCount');
        const lastUpdatedTimestamp = document.getElementById('lastUpdatedTimestamp');
        const refreshAllButton = document.getElementById('refreshAllButton');
        const rotateAllStaggeredButton = document.getElementById('rotateAllStaggeredButton');
        const statsModal = document.getElementById('statsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalStatsContent = document.getElementById('modalStatsContent');
        const closeModalButton = document.getElementById('closeModalButton');

        function formatTimeAgo(dateString) {
            // ... (same as before)
            if (!dateString || dateString.startsWith("0001-01-01")) return "Never";
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.round((now - date) / 1000);
            if (seconds < 0) return "Future";
            if (seconds < 5) return "Just now";
            if (seconds < 60) return `${seconds}s ago`;
            const minutes = Math.round(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.round(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            return `${Math.round(hours / 24)}d ago`;
        }

        function formatDuration(seconds) {
            // ... (same as before)
            if (typeof seconds !== 'number' || seconds < 0) return "N/A";
            if (seconds === 0) return "Disabled";
            if (seconds < 60) return `${seconds}s`;
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return s === 0 ? `${m}m` : `${m}m ${s}s`;
        }
        
        function formatSpeed(kbps) {
            if (typeof kbps !== 'number' || kbps <= 0) return "N/A";
            if (kbps < 1024) return `${kbps.toFixed(1)} KB/s`;
            return `${(kbps / 1024).toFixed(2)} MB/s`;
        }

        async function fetchData(urlPath, options = {}) {
            // ... (same as before)
            try {
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                if (!response.ok) {
                    const errorText = await response.text();
                    return { error: `HTTP ${response.status}: ${errorText.substring(0,150)}` };
                }
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.includes("application/json")) return await response.json();
                return { plain_text_response: await response.text() };
            } catch (error) { return { error: error.message }; }
        }

        async function postData(urlPath, body = null) {
            // ... (same as before, refined error reporting)
            try {
                const options = { method: 'POST', headers: {} };
                if (body) {
                    options.headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE_URL}${urlPath}`, options);
                const responseText = await response.text();
                if (!response.ok) {
                    let errorDetail = responseText;
                    try { const jsonError = JSON.parse(responseText); if (jsonError && jsonError.error) errorDetail = jsonError.error; } catch (e) {}
                    throw new Error(`HTTP ${response.status}: ${errorDetail.substring(0,200)}`);
                }
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.includes("application/json")) {
                    try { return JSON.parse(responseText); }
                    catch (e) { console.warn(`POST ${urlPath} OK, but non-JSON: ${responseText.substring(0,100)}`); return responseText; }
                }
                return responseText;
            } catch (error) {
                console.error(`POST error ${urlPath}:`, error);
                return { error: error.message, rawError: error };
            }
        }

        function createInstanceCard(instanceId) {
            if (document.getElementById(`instance-${instanceId}-card`)) return;

            const card = document.createElement('div');
            card.id = `instance-${instanceId}-card`;
            card.className = 'instance-card';
            card.innerHTML = `
                <h3>Instance ${instanceId}</h3>
                <p><span class="info-label">Status:</span> <span id="instance-${instanceId}-status-dot" class="status-dot status-unknown"></span><span id="instance-${instanceId}-status-text">Loading...</span></p>
                <p><small><span class="info-label">Active Conns (Proxy):</span> <span id="instance-${instanceId}-active-conns" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">External IP:</span> <span id="instance-${instanceId}-ip" class="info-value">Loading...</span> <button id="refresh-ip-btn-${instanceId}" class="btn-small" title="Refresh IP">ðŸ”„ IP</button></small></p>
                <p><small><span class="info-label">IP Last Change:</span> <span id="instance-${instanceId}-ip-change-time" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Circuit Last Rec.:</span> <span id="instance-${instanceId}-circuit-rec-time" class="info-value">N/A</span></small></p>
                
                <h4>Performance Metrics <button id="refresh-perf-btn-${instanceId}" class="btn-small" title="Refresh Performance Metrics">ðŸ”„ Perf</button></h4>
                <ul id="instance-${instanceId}-perf-metrics" class="perf-metrics-list"><li>Loading...</li></ul>

                <h4>Node Policy <button id="refresh-policy-btn-${instanceId}" class="btn-small" title="Refresh Node Policies">ðŸ”„ Policy</button></h4>
                <div class="node-policy-section">
                    <p><span class="info-label">ExitNodes:</span> <span id="instance-${instanceId}-exitnodes-current" class="info-value">N/A</span></p>
                    <input type="text" id="instance-${instanceId}-exitnodes-input" placeholder="e.g., {us},{gb} or DE,FR or IP" title="Comma-separated country codes (e.g., {us},{gb}), IPs, or fingerprints. Empty to clear.">
                    <button id="set-exitnodes-btn-${instanceId}">Set Exit</button>
                </div>
                 <div class="node-policy-section">
                    <p><span class="info-label">ExcludeNodes:</span> <span id="instance-${instanceId}-excludenodes-current" class="info-value">N/A</span></p>
                    <input type="text" id="instance-${instanceId}-excludenodes-input" placeholder="e.g., {ru},{cn} or specific IPs" title="Comma-separated country codes, IPs, or fingerprints. Empty to clear.">
                    <button id="set-excludenodes-btn-${instanceId}">Set Exclude</button>
                </div>
                <hr style="border:0; border-top: 1px solid #e5e7eb; margin: 15px 0;">
                <p><small><span class="info-label">Control:</span> <span id="instance-${instanceId}-control" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">SOCKS:</span> <span id="instance-${instanceId}-socks" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">DNS:</span> <span id="instance-${instanceId}-dns" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Bootstrap:</span> <span id="instance-${instanceId}-bootstrap" class="info-value">N/A</span></small></p>
                <p><small><span class="info-label">Version:</span> <span id="instance-${instanceId}-version" class="info-value">N/A</span></small></p>
                <div class="card-actions">
                    <button id="rotate-btn-${instanceId}">New Circuit <span id="rotate-spinner-${instanceId}" class="loading-spinner" style="display:none;"></span></button>
                    <button id="stats-btn-${instanceId}">View Full Stats</button>
                    <button id="refresh-instance-btn-${instanceId}" class="btn-small">Refresh All Instance Data</button>
                </div>
            `;
            instancesContainer.appendChild(card);
            attachInstanceEventListeners(instanceId);
        }

        function attachInstanceEventListeners(instanceId) {
            document.getElementById(`rotate-btn-${instanceId}`).addEventListener('click', () => handleNewCircuitClick(instanceId));
            document.getElementById(`stats-btn-${instanceId}`).addEventListener('click', () => showFullStats(instanceId));
            document.getElementById(`refresh-instance-btn-${instanceId}`).addEventListener('click', () => fetchAndRenderInstanceData(instanceId, true));
            document.getElementById(`refresh-ip-btn-${instanceId}`).addEventListener('click', () => refreshInstanceIP(instanceId));
            document.getElementById(`refresh-perf-btn-${instanceId}`).addEventListener('click', () => fetchInstancePerfMetrics(instanceId));
            document.getElementById(`refresh-policy-btn-${instanceId}`).addEventListener('click', () => fetchInstanceNodePolicies(instanceId));

            document.getElementById(`set-exitnodes-btn-${instanceId}`).addEventListener('click', () => 
                handleSetNodePolicy(instanceId, 'ExitNodes', document.getElementById(`instance-${instanceId}-exitnodes-input`).value)
            );
            document.getElementById(`set-excludenodes-btn-${instanceId}`).addEventListener('click', () => 
                handleSetNodePolicy(instanceId, 'ExcludeNodes', document.getElementById(`instance-${instanceId}-excludenodes-input`).value)
            );
        }
        
        async function handleSetNodePolicy(instanceId, policyType, nodes) {
            const buttonId = `set-${policyType.toLowerCase()}-btn-${instanceId}`;
            const originalButtonText = document.getElementById(buttonId).textContent;
            document.getElementById(buttonId).textContent = 'Setting...';
            document.getElementById(buttonId).disabled = true;

            const result = await postData(`/api/v1/instance/${instanceId}/config/nodepolicy`, { policy_type: policyType, nodes: nodes.trim() });
            
            document.getElementById(buttonId).textContent = originalButtonText;
            document.getElementById(buttonId).disabled = false;

            if (result.error) {
                alert(`Error setting ${policyType} for instance ${instanceId}: ${result.error}`);
            } else {
                alert(`${policyType} for instance ${instanceId} update initiated. Tor response: ${result.plain_text_response || JSON.stringify(result)}`);
                fetchInstanceNodePolicies(instanceId); // Refresh policy display
                 // Changing nodes often leads to new circuits, so IP might change.
                setTimeout(() => refreshInstanceIP(instanceId), 2000);
            }
        }


        function updateInstanceCardUI(instanceId, data) {
            const getEl = (suffix) => document.getElementById(`instance-${instanceId}-${suffix}`);
            if (!getEl('status-dot')) { console.warn(`UI elements for instance ${instanceId} not ready.`); return; }

            // Health
            const health = data.health;
            if (health && !health.error) {
                getEl('status-dot').className = health.cached_is_healthy ? 'status-dot status-healthy' : 'status-dot status-unhealthy';
                let statusStr = health.cached_is_healthy ? 'Healthy' : 'Unhealthy';
                if(health.last_health_check_at) statusStr += ` (chk ${formatTimeAgo(health.last_health_check_at)})`;
                getEl('status-text').textContent = statusStr;
            } else {
                getEl('status-dot').className = 'status-dot status-unknown';
                getEl('status-text').textContent = health ? `Error: ${health.error}` : 'Health N/A';
            }

            // Config (includes IP, active conns, timestamps, node policies from /config)
            const config = data.config;
            if (config && !config.error) {
                getEl('active-conns').textContent = config.active_proxy_connections !== undefined ? config.active_proxy_connections : 'N/A';
                getEl('ip').textContent = config.external_ip || 'N/A';
                getEl('ip-change-time').textContent = formatTimeAgo(config.last_ip_change_at);
                getEl('circuit-rec-time').textContent = formatTimeAgo(config.last_circuit_recreation_at);
                getEl('control').textContent = config.control_host || 'N/A';
                getEl('socks').textContent = config.backend_socks_host || 'N/A';
                getEl('dns').textContent = config.backend_dns_host || 'N/A';
                // Node policies from /config endpoint
                getEl('exitnodes-current').textContent = config.current_exitnode_policy || '(not set/default)';
                getEl('excludenodes-current').textContent = config.current_excludenode_policy || '(not set/default)';
            } else {
                ['active-conns', 'ip', 'ip-change-time', 'circuit-rec-time', 'control', 'socks', 'dns', 'exitnodes-current', 'excludenodes-current'].forEach(sfx => {
                    if (getEl(sfx)) getEl(sfx).textContent = config ? `Conf Err: ${config.error.substring(0,30)}` : 'N/A';
                });
            }
            
            // Stats (bootstrap, version)
            const stats = data.stats;
            if (stats && !stats.error) {
                const bsMatch = stats.bootstrap_status ? stats.bootstrap_status.match(/SUMMARY="([^"]+)"/) : null;
                getEl('bootstrap').textContent = bsMatch ? bsMatch[1] : (stats.bootstrap_status || 'N/A');
                if(stats.bootstrap_error) getEl('bootstrap').textContent += ` (Err: ${stats.bootstrap_error})`;
                getEl('version').textContent = stats.version || "N/A";
                if(stats.version_error) getEl('version').textContent += ` (Err: ${stats.version_error})`;
                 // If active_proxy_connections is in stats and not set by config, use it
                if (getEl('active-conns').textContent === 'N/A' && typeof stats.active_proxy_connections !== 'undefined') {
                     getEl('active-conns').textContent = stats.active_proxy_connections;
                }
            } else {
                if(getEl('bootstrap')) getEl('bootstrap').textContent = stats ? `Stats Err: ${stats.error.substring(0,30)}` : 'N/A';
                if(getEl('version')) getEl('version').textContent = "N/A";
            }

            // Performance Metrics
            const perfMetrics = data.perfMetrics; // This comes from /performancemetrics
            const perfList = getEl('perf-metrics');
            if (perfList) {
                if (perfMetrics && Object.keys(perfMetrics).length > 0 && !perfMetrics.error) {
                    perfList.innerHTML = ''; // Clear previous
                    Object.values(perfMetrics).forEach(metric => {
                        const li = document.createElement('li');
                        let valStr = "N/A";
                        if (metric.test_target && metric.test_target.includes("_latency")) {
                            valStr = metric.latency_ms > 0 ? `${metric.latency_ms} ms` : (metric.test_failures > 0 ? `Fail (${metric.test_failures})` : "N/A");
                        } else if (metric.test_target && metric.test_target.includes("_speed")) {
                            valStr = metric.download_speed_kbps > 0 ? formatSpeed(metric.download_speed_kbps) : (metric.test_failures > 0 ? `Fail (${metric.test_failures})` : "N/A");
                        }
                        const targetName = metric.test_target ? metric.test_target.replace(/_latency|_speed/g, '') : 'Unknown';
                        li.innerHTML = `<span class="metric-target">${targetName}:</span> <span class="metric-value">${valStr}</span> 
                                        <small>(tested ${formatTimeAgo(metric.last_test_time)})</small>
                                        ${metric.is_stale ? '<span class="metric-stale"> (stale)</span>' : ''}`;
                        perfList.appendChild(li);
                    });
                } else if (perfMetrics && perfMetrics.error) {
                     perfList.innerHTML = `<li>Error loading perf metrics: ${perfMetrics.error}</li>`;
                } else {
                    perfList.innerHTML = '<li>No performance data available.</li>';
                }
            }
        }
        
        async function refreshInstanceIP(instanceId) {
            const ipElem = document.getElementById(`instance-${instanceId}-ip`);
            if(ipElem) ipElem.textContent = 'Fetching IP...';
            await fetchData(`/api/v1/instance/${instanceId}/ip`); // This call updates IP on backend
            fetchInstanceConfig(instanceId); // Then refresh config to get updated IP and LastIPChangeTime
        }

        async function fetchInstanceConfig(instanceId) { // Fetches /config
            const configData = await fetchData(`/api/v1/instance/${instanceId}/config`);
            instancesData[instanceId] = { ...instancesData[instanceId], config: configData };
            updateInstanceCardUI(instanceId, instancesData[instanceId]);
        }
        async function fetchInstanceNodePolicies(instanceId) { // Specifically refreshes node policies from /config
            const configData = await fetchData(`/api/v1/instance/${instanceId}/config`); // /config now includes live policies
            instancesData[instanceId] = { ...instancesData[instanceId], config: configData };
            updateInstanceCardUI(instanceId, instancesData[instanceId]);
        }


        async function fetchInstancePerfMetrics(instanceId) { // Fetches /performancemetrics
            const perfData = await fetchData(`/api/v1/instance/${instanceId}/performancemetrics`);
            instancesData[instanceId] = { ...instancesData[instanceId], perfMetrics: perfData };
            updateInstanceCardUI(instanceId, instancesData[instanceId]);
        }


        async function showFullStats(instanceId) {
            // ... (same as before)
            modalTitle.textContent = `Full Stats for Instance ${instanceId}`;
            modalStatsContent.textContent = 'Loading stats...';
            statsModal.style.display = "block";
            const stats = await fetchData(`/api/v1/instance/${instanceId}/stats`);
            modalStatsContent.textContent = stats.error ? `Error: ${stats.error}` : JSON.stringify(stats, null, 2);
        }

        closeModalButton.onclick = () => { statsModal.style.display = "none"; }
        window.onclick = (event) => { if (event.target == statsModal) statsModal.style.display = "none"; }

        async function handleNewCircuitClick(instanceId) {
            // ... (same as before, ensure UI updates)
            const btn = document.getElementById(`rotate-btn-${instanceId}`);
            const spinner = document.getElementById(`rotate-spinner-${instanceId}`);
            btn.disabled = true; spinner.style.display = 'inline-block';
            const result = await postData(`/api/v1/instance/${instanceId}/rotate`);
            btn.disabled = false; spinner.style.display = 'none';
            if (result.error) {
                alert(`Error for instance ${instanceId}: ${result.error}`);
            } else {
                const statusEl = document.getElementById(`instance-${instanceId}-status-text`);
                if(statusEl) statusEl.textContent = 'Rotation requested...';
                setTimeout(() => fetchAndRenderInstanceData(instanceId, true), 2000); // Refresh sooner
            }
        }

        rotateAllStaggeredButton.onclick = async function() {
            // ... (same as before)
            this.disabled = true; this.textContent = "Rotating All (Streaming)...";
            try {
                const response = await fetch(`${API_BASE_URL}/rotate-all-staggered`, { method: 'POST' });
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                alert(`Staggered rotation initiated. Monitor UI/logs. UI will refresh.`);
            } catch (error) { alert(`Error: ${error.message}`); console.error(error); }
            this.disabled = false; this.textContent = "Rotate All Healthy Staggered";
            setTimeout(fetchAndRenderAllInstances, 5000);
        }

        function updateCommonProxyStatusDisplay() {
            // ... (same as before)
            let healthyCount = 0;
            const totalInstances = appDetails ? parseInt(appDetails.num_instances, 10) : 0;
            if (totalInstances > 0) {
                for (let i = 1; i <= totalInstances; i++) {
                    if (instancesData[i]?.health?.cached_is_healthy) healthyCount++;
                }
            }
            commonSocksPortDisplay.textContent = appDetails?.common_socks_port || 'N/A';
            commonDnsPortDisplay.textContent = appDetails?.common_dns_port || 'N/A';
            const statusText = (total, healthy) => !appDetails ? 'Loading...' : (total === 0 ? 'No instances.' : 
                (healthy > 0 ? `<span class="status-dot status-healthy"></span>Op (${healthy}/${total} healthy)` : 
                                 `<span class="status-dot status-unhealthy"></span>Off (0/${total} healthy)`));
            commonSocksStatus.innerHTML = statusText(totalInstances, healthyCount);
            commonDnsStatus.innerHTML = statusText(totalInstances, healthyCount);
        }
        
        function renderAppConfigDetails(details) {
            // ... (expanded for new config options)
            if (!details || details.error) { appConfigDetailsContainer.innerHTML = '<p>Error loading app config.</p>'; return; }
            let html = `<p><span class="info-label">Tor Instances:</span> <span class="info-value">${details.num_instances}</span></p>`;
            html += `<p><span class="info-label">API Port:</span> <span class="info-value">${details.api_port}</span></p>`;
            html += `<p><span class="info-label">Load Balancing:</span> <span class="info-value">${details.load_balancing_strategy || 'N/A'}</span></p>`;
            html += `<p><span class="info-label">Health Check Interval:</span> <span class="info-value">${formatDuration(details.health_check_interval_seconds)}</span></p>`;
            
            html += `<h4>Circuit Manager</h4>`;
            html += `<p><span class="info-label">CM Enabled:</span> <span class="info-value">${details.circuit_manager_enabled ? 'Yes' : 'No'}</span></p>`;
            if(details.circuit_manager_enabled) {
                html += `<p><span class="info-label">Max Circuit Age:</span> <span class="info-value">${formatDuration(details.circuit_max_age_seconds)}</span></p>`;
                html += `<p><span class="info-label">CM Stagger:</span> <span class="info-value">${formatDuration(details.circuit_rotation_stagger_seconds)}</span></p>`;
                html += `<p><span class="info-label">IP Diversity Enabled:</span> <span class="info-value">${details.ip_diversity_check_enabled ? 'Yes' : 'No'}</span></p>`;
                if(details.ip_diversity_check_enabled) {
                    html += `<p><span class="info-label">IP Div. Min Instances:</span> <span class="info-value">${details.ip_diversity_min_instances}</span></p>`;
                    html += `<p><span class="info-label">IP Div. Check Interval:</span> <span class="info-value">${formatDuration(details.ip_diversity_subnet_check_interval_seconds)}</span></p>`;
                    html += `<p><span class="info-label">IP Div. Cooldown:</span> <span class="info-value">${formatDuration(details.ip_diversity_rotation_cooldown_seconds)}</span></p>`;
                }
            }
             html += `<h4>Performance Tester</h4>`;
             html += `<p><span class="info-label">Perf Test Enabled:</span> <span class="info-value">${details.perf_test_enabled ? 'Yes' : 'No'}</span></p>`;
             if(details.perf_test_enabled) {
                html += `<p><span class="info-label">Perf Test Interval:</span> <span class="info-value">${formatDuration(details.perf_test_interval_seconds)}</span></p>`;
                html += `<p><span class="info-label">Latency Targets:</span></p><ul>`;
                for(const alias in details.latency_test_targets) { html += `<li>${alias}: ${details.latency_test_targets[alias]}</li>`; }
                html += `</ul>`;
                html += `<p><span class="info-label">Speed Test:</span> <span class="info-value">${details.speed_test_target_url}${details.speed_test_target_bytes}</span></p>`;
             }
            appConfigDetailsContainer.innerHTML = html;
        }

        async function fetchAndRenderInstanceData(instanceId, forceAll = false) {
            if (!document.getElementById(`instance-${instanceId}-card`)) createInstanceCard(instanceId);
            
            // Fetch all data points concurrently
            const dataPromises = [
                fetchData(`/api/v1/instance/${instanceId}/config`), // Includes basic status, IP, node policies
                fetchData(`/api/v1/instance/${instanceId}/health`), // Live health check
                fetchData(`/api/v1/instance/${instanceId}/stats`),  // Tor internal stats
                fetchData(`/api/v1/instance/${instanceId}/performancemetrics`) // Latency/speed
            ];

            try {
                const [config, health, stats, perfMetrics] = await Promise.all(dataPromises);
                instancesData[instanceId] = { config, health, stats, perfMetrics };
                updateInstanceCardUI(instanceId, instancesData[instanceId]);
            } catch (error) {
                console.error(`Error fetching data bundle for instance ${instanceId}:`, error);
                updateInstanceCardUI(instanceId, { // Show errors on UI
                    config: { error: 'Bundle fetch failed' }, health: { error: 'Bundle fetch failed' },
                    stats: { error: 'Bundle fetch failed' }, perfMetrics: { error: 'Bundle fetch failed' }
                });
            }
        }

        async function fetchAndRenderAllInstances() {
            if (!appDetails) {
                const details = await fetchData("/api/v1/app-details");
                appDetails = (details.error || !details.num_instances) ? 
                    { num_instances: 0, common_socks_port: 'N/A', common_dns_port: 'N/A', load_balancing_strategy: 'N/A' } : details;
                renderAppConfigDetails(appDetails);
            }
            instanceCountDisplay.textContent = appDetails.num_instances || 0;
            const numInstances = appDetails.num_instances || 0;

            if (numInstances === 0) {
                instancesContainer.innerHTML = '<p>No Tor instances configured.</p>';
            } else {
                const fetchPromises = [];
                for (let i = 1; i <= numInstances; i++) {
                    if (!document.getElementById(`instance-${i}-card`)) createInstanceCard(i);
                    fetchPromises.push(fetchAndRenderInstanceData(i));
                }
                await Promise.all(fetchPromises).catch(e => console.error("Error fetching all instance data:", e));
            }
            updateCommonProxyStatusDisplay();
            lastUpdatedTimestamp.textContent = new Date().toLocaleTimeString();
        }

        refreshAllButton.addEventListener('click', () => {
            lastUpdatedTimestamp.textContent = 'Refreshing...';
            appDetails = null; // Force refetch of app details
            fetchAndRenderAllInstances();
        });

        async function initializeUI() {
            await fetchAndRenderAllInstances();
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(fetchAndRenderAllInstances, REFRESH_INTERVAL_MS);
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
